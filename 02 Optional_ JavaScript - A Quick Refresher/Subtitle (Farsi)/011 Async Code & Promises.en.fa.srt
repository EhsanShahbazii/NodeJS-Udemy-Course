1
00:00:02,180 --> 00:00:09,410
نه، من دوباره سقوط سرقت ادبی را پاک کردم، زیرا برای پایان دادن به این ماژول تجدید سریع، شیرجه خواهم زد

2
00:00:09,410 --> 00:00:15,020
به مفهوم Novakovic و این نحوه کار با کد ناهمزمان است.

3
00:00:15,440 --> 00:00:20,120
و برای آن، اول از همه باید بفهمیم کد ناهمزمان چیست.

4
00:00:20,480 --> 00:00:25,700
فرض کنید من یک تایمر با زمان تعیین شده تنظیم کردم، که تابعی است که در Node JS تعبیه شده است.

5
00:00:26,450 --> 00:00:31,430
در آنجا تابعی را تعریف می کنیم که باید پس از مدت زمان مشخصی اجرا شود یا منقضی شود.

6
00:00:31,880 --> 00:00:33,620
در اینجا من از یک تابع فلش استفاده خواهم کرد.

7
00:00:33,830 --> 00:00:36,100
شما می توانید از یک تابع نامگذاری شده استفاده کنید، هر آنچه که دوست دارید.

8
00:00:37,040 --> 00:00:38,660
آرگومان دوم تایمر است.

9
00:00:38,660 --> 00:00:39,860
فرض کنید دو ثانیه.

10
00:00:40,010 --> 00:00:41,810
شما آن را در میلی ثانیه بیان می کنید.

11
00:00:41,810 --> 00:00:46,250
بنابراین دو ثانیه در آنها دو هزار میلی ثانیه است.

12
00:00:47,450 --> 00:00:49,700
در نهایت، به سادگی، تیمور تمام شد.

13
00:00:52,600 --> 00:00:59,920
اگر اکنون این فایل را برای دو ثانیه اجرا کنم، هیچ اتفاقی نمی افتد و سپس می بینیم که Taimur تمام شده است، اکنون این کار است

14
00:00:59,920 --> 00:01:06,430
کد ناهمزمان زیرا بلافاصله تمام نمی شود و حتی اگر یک میلی ثانیه داشته باشیم، یک کد خواهد بود.

15
00:01:06,430 --> 00:01:06,720
آنجا.

16
00:01:06,760 --> 00:01:14,860
بنابراین اگر فوق العاده سریع باشد، بلافاصله در قطعه کد ما اتفاق نمی افتد، مانند اگر ما یک کنسول داشته باشیم.

17
00:01:14,860 --> 00:01:15,370
قفل کردن.

18
00:01:16,550 --> 00:01:17,120
سلام.

19
00:01:18,920 --> 00:01:20,480
و لاگ کنسول

20
00:01:22,320 --> 00:01:28,800
سلام، این دو قطعه کد Synchronoss هستند زیرا بلافاصله پس از هم اجرا می شوند و

21
00:01:28,800 --> 00:01:34,650
البته از نظر فنی، نواد مدتی طول می کشد تا آنها را اجرا کند، اما هیچ تاخیر دیگری وجود ندارد

22
00:01:34,650 --> 00:01:39,050
از سخت افزار شما، به طوری که می گویند، و بنابراین یک کد Syncronoss.

23
00:01:39,240 --> 00:01:45,120
این یک کد ناهمزمان است زیرا بلافاصله اجرا یا تمام نمی شود.

24
00:01:45,210 --> 00:01:52,010
کمی زمان می برد، حتی اگر خیلی کوتاه باشد و در واقع، اگر من این فایل را اینگونه اجرا کنم، شما

25
00:01:52,050 --> 00:02:00,060
قبل از اینکه ببینید تمام شد، سلام و سلام را ببینید، حتی اگر خیلی سریع است زیرا هیچ بررسی و جاوا اسکریپت وجود ندارد

26
00:02:00,060 --> 00:02:05,660
به طور کلی تا زمانی که این کار انجام نشود، اجرای کد شما را مسدود نمی کند.

27
00:02:06,180 --> 00:02:11,600
در واقع، در اینجا این به اصطلاح تابع callback را تشخیص خواهد داد.

28
00:02:11,940 --> 00:02:14,370
بنابراین یک تابع باید در آینده اجرا شود.

29
00:02:14,370 --> 00:02:18,120
پس از اتمام باید بعداً تماس بگیرد.

30
00:02:18,120 --> 00:02:24,480
بنابراین هنگامی که تایمر در اینجا منقضی شد، فقط آن را تشخیص می دهد و بلافاصله به سراغ آن می رود

31
00:02:24,480 --> 00:02:31,890
خط بعدی و تمام کدهای همزمان را اجرا می کند و پس از انجام این کار، کد async شما را اجرا می کند.

32
00:02:32,310 --> 00:02:37,830
به همین دلیل است که می بینیم ابتدا چقدر کم و زیاد است، حتی اگر در کد ما ابتدا Thomaston چاپ شده است.

33
00:02:38,190 --> 00:02:43,440
و این یک مفهوم حیاتی است که باید در جاوا اسکریپت و به خصوص گره درک کنید.

34
00:02:43,590 --> 00:02:47,160
و من در طول دوره به آن باز خواهم گشت زیرا بسیار مهم است.

35
00:02:48,470 --> 00:02:53,390
اکنون، هنگام کار با آن، و من دوباره تا دو ثانیه افزایش می‌دهم تا واضح‌تر شود،

36
00:02:54,230 --> 00:02:56,810
سپس دوباره خواهید دید که کد همگام سازی ما اجرا می شود.

37
00:02:56,810 --> 00:02:59,000
و بعد از دو ثانیه این کد اجرا می شود.

38
00:02:59,600 --> 00:03:05,390
هنگام کار با کد async، تکنیک های متعددی برای مدیریت خوب آن دریافت می کنیم.

39
00:03:06,260 --> 00:03:12,400
تابع callback یکی، قدیمی ترین است، و شما آن را کاملاً مشاهده خواهید کرد، به خصوص بدنام.

40
00:03:12,650 --> 00:03:14,060
عیبی نداره

41
00:03:14,390 --> 00:03:20,370
اما اگر چند عملیات وابسته به همگام داشته باشید با مشکل مواجه خواهید شد.

42
00:03:20,960 --> 00:03:27,260
بنابراین در اینجا تایمر را تنظیم می کنیم و حالا فرض کنید من یک تابع ایجاد می کنم.

43
00:03:29,880 --> 00:03:32,370
که واکشی داده ها را نامگذاری می کند.

44
00:03:34,280 --> 00:03:40,400
و در آنجا، من فقط یک تایمر تنظیم می کنم، زیرا نمی خواهم پایگاه داده یا چیز دیگری را تنظیم کنم

45
00:03:40,550 --> 00:03:43,670
مانند آن، جایی که ما داده ها را از آن واکشی می کنیم، همه این کارها را در طول دوره انجام می دهد.

46
00:03:43,670 --> 00:03:44,140
البته.

47
00:03:44,150 --> 00:03:44,630
جای نگرانی نیست.

48
00:03:45,230 --> 00:03:51,320
بنابراین در اینجا دوباره، من یک تایمر دیگر در آنجا دارم که یک و نیم ثانیه طول می کشد.

49
00:03:54,440 --> 00:04:02,450
و اکنون اینجا در Fetch Data، من به روشی نیاز دارم، خوب، در تمام این مدت یا آن زمان کاری انجام دهم

50
00:04:02,450 --> 00:04:02,840
انجام شده.

51
00:04:03,290 --> 00:04:08,810
بنابراین در اینجا من در واقع انتظار استدلالی را خواهم داشت که نام آن را بازخوانی می کنم، زیرا این استدلال خواهد بود

52
00:04:08,810 --> 00:04:15,380
تابعی که در نهایت به محض اینکه کار با تایمر را تمام کردم، تابع درونی خود را در اینجا فراخوانی خواهم کرد

53
00:04:15,380 --> 00:04:15,980
می تواند عبور کند.

54
00:04:15,980 --> 00:04:17,240
به عنوان یک ارزش انجام شد.

55
00:04:17,680 --> 00:04:22,970
حالا، در جایی که از داده‌های واکشی استفاده می‌کنم، فرض کنید در داخل این زمان تنظیم شده است، تماس می‌گیرم.

56
00:04:24,030 --> 00:04:30,120
من واکشی داده‌ها را در آنجا صدا می‌کنم، اکنون باید یک تماس دیگر را به عقب و اینجا ارسال کنم.

57
00:04:31,180 --> 00:04:37,450
وقتی آن را اجرا می‌کنم، متن ارسالی را دریافت می‌کنم تا در تابع من دوباره فراخوانی شود، بنابراین مقداری بافت دریافت می‌کنیم

58
00:04:38,260 --> 00:04:40,520
و آیکون کنسول آن متن را قفل می کند.

59
00:04:41,470 --> 00:04:43,650
اکنون، این ممکن است در پایان در اینجا گیج کننده به نظر برسد.

60
00:04:43,660 --> 00:04:49,330
من تابع خودم را ایجاد می کنم که یک فراخوان دریافت می کند تا بتوانم تابعی را تعریف کنم که باید اجرا شود

61
00:04:49,330 --> 00:04:52,570
زمانی که این تایمر داخلی از جای دیگری انجام شود.

62
00:04:52,600 --> 00:04:57,070
بنابراین از این مکان در اینجا، این تابعی است که به طور موثر به عنوان یک تماس ارسال می شود.

63
00:04:57,400 --> 00:04:59,080
و من این تابع را در اینجا اجرا می کنم.

64
00:04:59,890 --> 00:05:02,050
حالا، اگر آن را ذخیره کنم، آن را اجرا می کنم.

65
00:05:03,350 --> 00:05:08,000
دو ثانیه طول می کشد، سپس زمان تایمر تمام می شود و بعد از یک و نیم ثانیه، می بینم

66
00:05:08,000 --> 00:05:08,340
انجام شده.

67
00:05:09,050 --> 00:05:16,790
اکنون، اگر چند تماس ناهمگام تودرتو داشته باشیم، همانطور که در اینجا داریم، از یک تماس برگشتی عمیق‌تر و عمیق‌تر می‌شویم.

68
00:05:16,790 --> 00:05:17,630
چشم انداز.

69
00:05:18,260 --> 00:05:23,620
و به همین دلیل است که ما یک ویژگی به نام Promises نیز داریم که می توانیم از آن استفاده کنیم.

70
00:05:23,630 --> 00:05:29,350
نوکیا در حال حاضر اغلب از بسته‌های شخص ثالثی استفاده می‌کند که قبلاً از قول‌هایی برای ما استفاده می‌کردند.

71
00:05:29,960 --> 00:05:34,420
بنابراین Syntex که اکنون به شما نشان خواهم داد یکی از مواردی است که به ندرت مجبور به نوشتن آن هستید.

72
00:05:34,820 --> 00:05:37,450
که توسط بسته های پشت صحنه انجام خواهد شد.

73
00:05:37,940 --> 00:05:41,270
هنوز خوشحالم که می‌دانم یک وعده ایجاد کرده‌اید.

74
00:05:42,410 --> 00:05:45,110
در داخل وضعیت ما از عملکرد یا بیایید بگوییم.

75
00:05:48,160 --> 00:05:53,510
با ذخیره آن در یک ثابت یا متغیر و سپس با استفاده از کلمه کلیدی جدید که در جاوا اسکریپت استفاده می کنید.

76
00:05:53,510 --> 00:05:59,830
برای ایجاد یک شی جدید بر اساس سازنده، اگر توابع سازنده چیزی است که به شما می گوید

77
00:05:59,830 --> 00:06:00,310
هیچ چی.

78
00:06:00,580 --> 00:06:07,510
برخی از منابع مقدماتی اولیه جاوا اسکریپت را بررسی کنید زیرا توابع سازنده یک ویژگی اصلی هستند

79
00:06:07,510 --> 00:06:08,380
در جاوا اسکریپت

80
00:06:09,040 --> 00:06:15,020
و در اینجا از تابع سازنده وعده استفاده می کنید که در جاوا اسکریپت و بدنام تعبیه شده است.

81
00:06:16,320 --> 00:06:22,590
و در واقع تماسی نیز وجود دارد که به بحث، حل و فصل و رد می‌شود، شما می‌توانید

82
00:06:22,590 --> 00:06:25,080
آنها را هر طور که می خواهید نام گذاری کنید، اما این دو تابع هستند.

83
00:06:25,530 --> 00:06:28,830
و اولی وعده را با موفقیت انجام می دهد.

84
00:06:28,830 --> 00:06:30,690
آن را با موفقیت حل می کند.

85
00:06:31,050 --> 00:06:34,620
دومی آن را رد می کند که مانند پرتاب خطا است.

86
00:06:35,520 --> 00:06:38,310
سپس کد async خود را می گیرید و آن را به آنجا منتقل می کنید.

87
00:06:38,490 --> 00:06:41,300
و دوباره، شما واقعاً باید این را خودتان بنویسید.

88
00:06:41,460 --> 00:06:46,860
اکثر بسته‌ها قبلاً این کار را برای شما انجام می‌دهند و به شما قول تمام شده را می‌دهند، که تمام کارهای جادویی را انجام می‌دهد

89
00:06:46,860 --> 00:06:48,580
صحنه های پنهان از تو

90
00:06:48,990 --> 00:06:50,110
در اینجا ما آن را به صورت دستی انجام می دهیم.

91
00:06:50,610 --> 00:06:55,140
بنابراین اکنون در آن فراخوانی، ما مجموعه عملکرد خود را داریم.

92
00:06:55,140 --> 00:06:58,470
متأسفانه تایمر به ما یک API قول نمی دهد.

93
00:06:58,480 --> 00:07:01,740
بنابراین در اینجا ما نیز باید از یک callback استفاده کنیم، اما در آنها.

94
00:07:03,620 --> 00:07:10,660
اکنون می دانیم که دیگر از هیچ تابع برگشتی که دریافت می کنیم استفاده نمی کنیم

95
00:07:11,120 --> 00:07:20,150
در عوض اینجا من حل کردم انجام شد. فرض کنید بنابراین من با موفقیت مقدار نتیجه را اکنون در واکشی داده ها برگرداندم

96
00:07:20,420 --> 00:07:22,160
بعد از تعریف قول

97
00:07:22,580 --> 00:07:23,990
فقط باید آن را برگردانیم.

98
00:07:24,470 --> 00:07:27,360
و لطفا توجه داشته باشید که این کد همزمان است.

99
00:07:27,620 --> 00:07:33,380
بنابراین در واقع این بلافاصله پس از ایجاد وعده قبل از کد موجود در کد بازگردانده می شود

100
00:07:33,380 --> 00:07:39,800
وعده اجرا می شود، که زمانی بعداً زمانی که ما آن تابع را فراخوانی می کنیم و زمانی که این اتفاق می افتد، اتفاق می افتد

101
00:07:39,800 --> 00:07:41,020
زمان اودن تکمیل می شود.

102
00:07:41,660 --> 00:07:48,140
بنابراین ما اکنون آن وعده را به اینجا برمی گردانیم و در مکانی که داده های واکشی شده را می نامیم، دیگر نمی گذریم

103
00:07:48,140 --> 00:07:55,340
یک callback، اما اکنون می‌توانیم از آن زمان استفاده کنیم، که در یک وعده قابل فراخوانی است و ما یک وعده را برمی‌گردانیم.

104
00:07:56,840 --> 00:08:03,350
و این به سادگی به ما اجازه می دهد تا تابع روز فراخوانی شده را در اینجا تعریف کنیم، که یک بار وعده اجرا می شود

105
00:08:03,350 --> 00:08:04,250
حل می شود.

106
00:08:07,440 --> 00:08:11,880
حال، اگر چنین وعده‌های متعددی داشته باشیم، چه مزیتی دارد؟

107
00:08:13,350 --> 00:08:19,950
بنابراین فرض کنید من به حالت واکشی زنگ زدم، وارد آنجا می‌شوم، پس مجبور نیستم از آن به این شکل استفاده کنم.

108
00:08:21,080 --> 00:08:24,110
و بنابراین، من با تو در تو پایان خواهم داد.

109
00:08:25,490 --> 00:08:26,630
دوباره تماس می گیرد.

110
00:08:27,690 --> 00:08:36,690
اما در عوض، داخل یک وعده و سپس مسدود کردن بخشی از یک وعده است، من نمی توانم فقط یک قول جدید را برگردانم

111
00:08:37,320 --> 00:08:42,660
و سپس بعدی و سپس بلوک بعد از قبلی را اضافه کنید.

112
00:08:46,300 --> 00:08:53,050
مانند این، بنابراین اکنون ما یک زنجیره را قطع می کنیم، سپس مسدود می کنیم، این یکی در وعده اول فراخوانی می شود، سپس

113
00:08:53,050 --> 00:08:55,600
در آن بلاک من قول دیگری را برمی گردانم.

114
00:08:55,910 --> 00:09:01,840
و حتی اگر این به ما قولی نمی داد، به جای بازگشت بلوک، تبدیل می شود

115
00:09:01,840 --> 00:09:04,120
آن را به قولی که فورا حل می شود.

116
00:09:04,600 --> 00:09:09,040
و سپس بلوک دیگری را اضافه می کنیم که اکنون به این قول در اینجا اشاره می کند.

117
00:09:09,670 --> 00:09:14,020
و این قابل خواندن تر از داشتن تماس های تو در تو بی نهایت است.

118
00:09:14,770 --> 00:09:18,490
بنابراین حالا اگر آن را اجرا کنم، می بینیم که تایمر چقدر بالا است.

119
00:09:19,000 --> 00:09:22,860
کار را انجام دادیم و دوباره می نشینیم چون من دوبار با fetch data تماس می گیرم.

120
00:09:23,800 --> 00:09:27,640
بنابراین ممکن است برای اولین بار پیچاندن سرتان به اطراف دشوار باشد.

121
00:09:28,000 --> 00:09:29,920
در طول این دوره از آن مجددا استفاده خواهیم کرد.

122
00:09:29,920 --> 00:09:31,370
در آن زمان روشن تر خواهد شد.

123
00:09:31,630 --> 00:09:40,510
باز هم، این کد عمدتا توسط شما نوشته نشده است، اما این یک مفهوم مهم است که باعث می شود کد غیر همگام ما

124
00:09:40,630 --> 00:09:41,970
قابل مدیریت تر

125
00:09:42,730 --> 00:09:45,760
همیشه راه دیگری برای مدیریت این همگام سازی وجود دارد.

126
00:09:45,760 --> 00:09:51,700
منتظر دو کلمه کلیدی خاص باشید که می توانید در جاوا اسکریپت مدرن استفاده کنید، و من یک بخش جداگانه در مورد آن خواهم داشت

127
00:09:51,700 --> 00:09:53,170
این در اواخر دوره

128
00:09:53,380 --> 00:09:58,960
من نمی خواهم آن را در اینجا معرفی کنم زیرا در واقع می تواند گیج کننده تر از این نحو در اینجا باشد.

129
00:09:59,080 --> 00:10:04,120
و من می خواهم به این یکی بچسبم تا ویژگی های جدید زیادی را به طور همزمان در اینجا معرفی نکنم.

130
00:10:04,900 --> 00:10:07,660
کد Async چیزی است که باید آن را درک کنید.

131
00:10:07,780 --> 00:10:13,600
و اگر تا به حال کاملاً مشخص نشده باشد، خوب است، اگرچه شما آن را برای تمام دوره یک دسته خواهید دید،

132
00:10:13,600 --> 00:10:20,190
زیرا ما در Notorious رویدادهای ناهمزمان زیادی داریم و من این را چندین بار توضیح خواهم داد.

133
00:10:20,200 --> 00:10:22,030
قول ها رو هم توضیح میدم

134
00:10:22,030 --> 00:10:28,750
باز هم، من فقط می‌خواهم اطمینان حاصل کنم که شما تا به حال این موضوع را دیده‌اید و فرصتی برای درک آن دارید

135
00:10:28,750 --> 00:10:31,240
این، چگونه کار می کند و چگونه با آن برخورد می کنیم.